/**
 * Copyright 2014 Modeliosoft
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.modelio.juniper;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

import mpi.MPI;

import org.modelio.juniper.data.MethodInvocation;
import org.modelio.juniper.data.MethodReturn;
import org.modelio.juniper.data.partitioning.BroadcastDataPartitioner;
import org.modelio.juniper.data.partitioning.DataPartitioner;
import org.modelio.juniper.data.partitioning.DataPartitioningStrategy;
import org.modelio.juniper.platform.JuniperProgram;

import eu.juniper.platform.models.ApplicationModel;
import eu.juniper.platform.models.auxiliary.CloudNode;
import eu.juniper.platform.models.auxiliary.DataConnection;
import eu.juniper.platform.models.auxiliary.Program;

/**
 * The communication toolkit that abstracts MPI communication details from JUNIPER programs.
 * 
 * @author marcos.almeida@softeam.fr
 */
public class CommunicationToolkit {

	private ExecutionLogger logger;
	private CommunicationSubsystem<String>  platformCommunicationSubsystem;

	/**
	 * @param juniperProgram the juniper program associated with this toolkit object
	 */
	public CommunicationToolkit(JuniperProgram juniperProgram) {
		this.thisProgram = juniperProgram;
		this.platformCommunicationSubsystem = new JuniperPlatformCommunicationSubsystem(thisProgram);
	}
	
	/**
	 * @param proxy
	 * @return
	 */
	public int getGroupSize(Object proxy) {
		ProxyFor proxyFor = this.requiredProxies.get(proxy);
		try {
			String dataConnectionName = getOutboundDataConnectionForProgram(proxyFor.getProgram());
			return getPartitionSizeForDataConnection(dataConnectionName);
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}		
	}
	
	// XXX: The proxies generated by this interface are probably not synchronized! 
	/**
	 * Generates a proxy to the given interface that implements method calls as MPI communication.
	 * 
	 * <b>IMPORTANT:</b> <em>void</em> methods are implemented as asynchronous method calls, whereas other methods are implemented as synchronous method calls.
	 * 
	 * @param program The target JUNIPER program.
	 * @param iface   The interface provided by the target program.
	 * @return the proxy
	 */
	@SuppressWarnings("rawtypes")
	public Object getProxyToInterface(final Class program, final Class iface) {

		try {
			Object proxy = Proxy.newProxyInstance(program.getClassLoader(),
					new Class[] { iface }, new InvocationHandler() {

						public Object invoke(Object obj, Method m, Object[] args)
								throws Throwable {
							if ("hashCode".equals(m.getName())) {
								return program.hashCode() + iface.hashCode();
							}
							
							if (args == null) {
								args = new Object[0];
							}
							String dataConnectionName = getOutboundDataConnectionForProgram(program);
							int    nbPartitions = getPartitionSizeForDataConnection(dataConnectionName);							
							Serializable token = logger.logSendBefore(program, m);
							
							if (isOneToAllDataConnection(dataConnectionName)) {								
								DataPartitioner partitioner = null; 
								if (m.isAnnotationPresent(DataPartitioningStrategy.class)) {
									DataPartitioningStrategy partitioningStrategy = m.getAnnotation(DataPartitioningStrategy.class);
									partitioner = (DataPartitioner) partitioningStrategy.partitioner().newInstance();
								} else {
									partitioner = new BroadcastDataPartitioner();
								}
								
								ArrayList<Serializable> toSend = new ArrayList<Serializable>(nbPartitions);
								Object argument = args[0];
								if (argument instanceof Collection) {
									for(Collection collection : partitioner.partition(nbPartitions, (Collection) argument)) {
										toSend.add(
												new MethodInvocation(iface.getName(), 
																	 m.getName(), 
																	 new Serializable[]{(Serializable) collection}, 
																	 token));
									}
								} else {
									for(int i=0;i<nbPartitions; ++i) {
										toSend.add(
												new MethodInvocation(iface.getName(), 
																	 m.getName(), 
																	 new Serializable[]{(Serializable) argument}, 
																	 token));										
									}
								}
								platformCommunicationSubsystem.sendObjects(dataConnectionName, toSend);																	
							} else {
								platformCommunicationSubsystem.sendObject(dataConnectionName,
										new MethodInvocation(iface.getName(), m.getName(), Arrays.copyOf(args, args.length, Serializable[].class), token));								
							}
							
							if (!Void.TYPE.equals(m.getReturnType())) {
								MethodReturn mr = (MethodReturn) platformCommunicationSubsystem.receiveReturnValue(dataConnectionName);
								Object ret = mr.getValue();
								
								logger.logSendAfter(program, m, token);								
								return ret;
							} else {								
								logger.logSendAfter(program, m, token);								
								return null;
							}
						}
					});
			registerProxy(proxy, program, iface);
			return proxy;
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}

	protected boolean isOneToAllDataConnection(String dataConnectionName) {
		ApplicationModel model = this.thisProgram.getJuniperPlatform().getApplicationModel();
		DataConnection dataConnection = model.getCommunicationModel().getDataConnectionByName(dataConnectionName);
		return "one_to_all".equals(dataConnection.getType());
	}

	private class ProxyFor {
		private Class program;
		private Class iface;
		public ProxyFor(Class program, Class iface) {
			super();
			this.program = program;
			this.iface = iface;
		}
		public Class getProgram() {
			return program;
		}
		public Class getIface() {
			return iface;
		}
		
	}
	
	@SuppressWarnings("rawtypes")
	private HashMap<Object, ProxyFor> requiredProxies = new HashMap<Object, ProxyFor>(); 

	private void registerProxy(Object proxy, Class program, Class iface) {
		requiredProxies.put(proxy, new ProxyFor(program, iface));
	}

	private String getOutboundDataConnectionForProgram(Class program) throws Exception {
		ApplicationModel model = this.thisProgram.getJuniperPlatform().getApplicationModel();
		int otherRank = getRank(program);
		ArrayList<String> otherGroups = model.getGroupModel().getGroupsOfMpiRank(otherRank);
		
		for(String dataConnectionName : this.thisProgram.getOutboundConnections()) {
			DataConnection dataConnection = model.getCommunicationModel().getDataConnectionByName(dataConnectionName);
			if (otherGroups.contains(dataConnection.getReceiverGroup())) {
				return dataConnectionName;
			}
		}
		throw new RuntimeException("Outbound data connection for " + program.getSimpleName() + " not found!");
	}
	
	private int getPartitionSizeForDataConnection(String dataConnectionName) throws Exception {
		ApplicationModel model = this.thisProgram.getJuniperPlatform().getApplicationModel();
		DataConnection dataConnection = model.getCommunicationModel().getDataConnectionByName(dataConnectionName);
		return model.getGroupModel().getGroupSize(dataConnection.getReceiverGroup());
	}	
	
	private Class getSourceProgramClassForInboundDataConnection(String dataConnectionName) throws ClassNotFoundException {
		ApplicationModel model = this.thisProgram.getJuniperPlatform().getApplicationModel();
		DataConnection dataConnection = model.getCommunicationModel().getDataConnectionByName(dataConnectionName);
		
		String rank = model.getGroupModel().getMpiglobalranksByGroupName(dataConnection.getSenderGroup()).get(0);
		String programName = model.getGroupModel().getProgramNameForGlobalRank(rank);
		
		return Class.forName(model.getProgramModel().getProgramByName(programName).getJavaClass());
	}

	@SuppressWarnings("rawtypes")
	private HashMap<Class, Set<Object>> providedInterfaces = new HashMap<Class, Set<Object>>(); 
	private JuniperProgram thisProgram;
		
	public JuniperProgram getJuniperProgram() {
		return thisProgram;
	}

	/**
	 * Initializes communication interfaces for a given JUNIPER program
	 * 
	 * @param program the JUNIPER program
	 */
	public void initProgramCommunication() {
		System.out.println("[ "+ this.thisProgram.getClass().getSimpleName() + "] init");
		logger = new ExecutionLogger(this.thisProgram);
	}
	
	/**
	 * Initializes communication interfaces for a given JUNIPER program
	 * 
	 * @param exclusionList file containing the list of excluded attributes at communication
	 * @throws IOException if there is an error reading the exclusion list
	 */
	private void initProgramCommunication(String exclusionListFileName) throws IOException {
		initProgramCommunication();
	}
		
	/**
	 * Initializes a provided interface of the JUNIPER program calling this method.
	 * 
	 * @param target the JUNIPER program that requires this interface.
	 * @param impl   an implementation to the provided interface provided by the JUNIPER program calling this method.
	 */
	public void initProvidedInterface(
			@SuppressWarnings("rawtypes") final Class target, final Object impl) {
		Set<Object> interfaces = providedInterfaces.get(target);
		if (interfaces == null) {
			interfaces = new HashSet<Object>();
			providedInterfaces.put(target, interfaces);
		}
		
		interfaces.add(impl);		
	}

	// TODO: Delete
	private int getRank(@SuppressWarnings("rawtypes") Class program)
			throws Exception {
		String rankStr = System.getProperty(program.getName()+"_rank");
		if (rankStr != null) {
			return Integer.parseInt(rankStr);
		} else {
			try {				
				Field rankField = program.getDeclaredField("RANK");
				rankField.setAccessible(true);
				int ret = (Integer) rankField.get(null);
				return ret;
			} catch(Exception e) {
				if (thisProgram instanceof JuniperProgram) {
					Integer rank = getRankFromApplicationModel(((JuniperProgram)thisProgram).getApplicationModel(), program.getName());
					if (rank != null) {
						return rank;
					}
				}
				throw new RuntimeException("Can't run without a rank for: "+ program.getName());				
			}
		}
	}

	private Integer getRankFromApplicationModel(
			ApplicationModel applicationModel, String programClassName) throws Exception {
		Program program = applicationModel.getProgramModel().getProgramByJavaClassName(programClassName);
		for(int i=0;i<MPI.COMM_WORLD.getSize();++i) {
			CloudNode node = applicationModel.getDeploymentModel().getCloudNodeByMpiglobalrank(i);
			String programName = applicationModel.getGroupModel().getProgramNameForGlobalRank(""+i);
			if (programName.equals(program.getName())) {
				return i;
			}
		}
		return null;
	}

	/**
	 * Fetches MPI messages and distributes them to the interface implementations provided to <em>initProvidedInterface</em>   
	 * 
         * @return a number of (received and) processed messages
	 * @throws Exception If a network error occurs at MPI level
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public int processReceivedMessages() throws Exception {
                int processedMessages = 0;
		for(String dataConnectionName : this.thisProgram.getInboundConnections()) {
			if (platformCommunicationSubsystem.hasObject(dataConnectionName)) {
				Serializable message = platformCommunicationSubsystem.receiveObject(dataConnectionName);
				MethodInvocation mi = null;
				if (message instanceof MethodInvocation) {
					mi = (MethodInvocation) message;
				} else if (message instanceof ArrayList) {
					ArrayList<Object> messages = (ArrayList<Object>) message;
					mi = (MethodInvocation) messages.get(0); // TODO support multiple method calls!

					// initializes the collection with the values in the first message
					Collection cmi = ((Collection)mi.getParameters()[0]);

					// adds the values from the other messages to cmi
					for (int i=1;i<messages.size();++i) {
						MethodInvocation mib = (MethodInvocation) messages.get(i);
						Collection cmib = ((Collection)mib.getParameters()[0]);
						cmi.addAll(cmib);
					}
					
					// since it modifies cmi and cmi is the parameters of message 1... 
					// it will call the method of message 1 with the parameters of all messages
				}

				Class sourceProgramClass = getSourceProgramClassForInboundDataConnection(dataConnectionName);
				for(Object proxy : providedInterfaces.get(sourceProgramClass)) {
					if (implementsInterface(proxy, mi.getInterfaceName())) {
						for (Method m : proxy.getClass().getMethods()) {
							if (m.getName().equals(mi.getMethodName())) {
								if (!m.isAccessible()) {
									m.setAccessible(true);
								}

								logger.logReceive(sourceProgramClass, m, mi.getToken());
								Object ret = m.invoke(proxy, mi.getParameters());
								if (!Void.TYPE.equals(m.getReturnType())) { 
									// TODO: add this to generator!
									platformCommunicationSubsystem.sendReturnValue(dataConnectionName, new MethodReturn(ret));
								}
							}
						}																		
					}
				}

                processedMessages++;
			} else {
				Thread.yield();	
			}
		}
                return processedMessages;
	}

	private static boolean implementsInterface(Object proxy,
			String interfaceName) {
		for(@SuppressWarnings("rawtypes") Class iface : proxy.getClass().getInterfaces()) {
			if (iface.getName().equals(interfaceName)) {
				return true;
			}
		}
		return false;
	}

}
